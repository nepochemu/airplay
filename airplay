#!/usr/bin/env python3
import argparse
import json
import os
import re
import shutil
import socket
import subprocess
import sys
from typing import Any, Dict, List, Optional, Tuple


def run(cmd: List[str], check: bool = True) -> str:
    try:
        out = subprocess.check_output(cmd, stderr=subprocess.STDOUT, text=True)
        return out
    except FileNotFoundError:
        raise
    except subprocess.CalledProcessError as e:
        if check:
            raise RuntimeError(e.output.strip())
        return e.output


def require_tool(name: str) -> None:
    if shutil.which(name) is None:
        raise RuntimeError(f"Missing required tool: {name}")


def config_path() -> str:
    base = os.environ.get("XDG_CONFIG_HOME") or os.path.expanduser("~/.config")
    return os.path.join(base, "airplay-cli", "config.json")


def load_config() -> Dict[str, Any]:
    path = config_path()
    if not os.path.exists(path):
        return {}
    try:
        with open(path, "r", encoding="utf-8") as f:
            return json.load(f)
    except Exception:
        return {}


def save_config(cfg: Dict[str, Any]) -> None:
    path = config_path()
    os.makedirs(os.path.dirname(path), exist_ok=True)
    with open(path, "w", encoding="utf-8") as f:
        json.dump(cfg, f, indent=2)


def load_pw_dump() -> List[Dict[str, Any]]:
    require_tool("pw-dump")
    raw = run(["pw-dump"])
    return json.loads(raw)


def is_airplay_sink(props: Dict[str, Any]) -> bool:
    hay = []
    for key in (
        "device.protocol",
        "node.name",
        "node.description",
        "node.nick",
        "device.product.name",
        "device.description",
    ):
        val = props.get(key)
        if isinstance(val, str):
            hay.append(val.lower())
    joined = " ".join(hay)
    if "raop" in joined or "airplay" in joined:
        return True
    proto = props.get("device.protocol")
    if isinstance(proto, str) and proto.lower() == "raop":
        return True
    return False


def detect_backend() -> str:
    if shutil.which("wpctl") and shutil.which("pw-dump"):
        try:
            run(["pw-dump"])
            return "pipewire"
        except Exception:
            pass
    if shutil.which("pactl"):
        return "pulseaudio"
    return "unknown"


def get_sinks_pipewire() -> List[Dict[str, Any]]:
    data = load_pw_dump()
    sinks: List[Dict[str, Any]] = []
    for obj in data:
        if obj.get("type") != "PipeWire:Interface:Node":
            continue
        info = obj.get("info") or {}
        props = info.get("props") or {}
        if props.get("media.class") != "Audio/Sink":
            continue
        sinks.append(
            {
                "id": obj.get("id"),
                "name": props.get("node.name") or "",
                "description": props.get("node.description")
                or props.get("device.description")
                or props.get("node.nick")
                or "",
                "props": props,
                "backend": "pipewire",
            }
        )
    return sinks


def get_sinks_pulseaudio() -> List[Dict[str, Any]]:
    require_tool("pactl")
    raw = run(["pactl", "list", "sinks"])
    blocks = raw.split("Sink #")
    sinks: List[Dict[str, Any]] = []
    for block in blocks[1:]:
        m_id = re.search(r"^(\d+)\n", block)
        if not m_id:
            continue
        sid = int(m_id.group(1))
        m_name = re.search(r"^\s*Name:\s*(\S+)", block, re.MULTILINE)
        m_desc = re.search(r"^\s*Description:\s*(.+)$", block, re.MULTILINE)
        name = m_name.group(1) if m_name else ""
        desc = m_desc.group(1).strip() if m_desc else ""
        props = {"node.name": name, "node.description": desc}
        sinks.append(
            {
                "id": sid,
                "name": name,
                "description": desc,
                "props": props,
                "backend": "pulseaudio",
            }
        )
    return sinks


def get_sinks(backend: str) -> List[Dict[str, Any]]:
    if backend == "pipewire":
        return get_sinks_pipewire()
    if backend == "pulseaudio":
        return get_sinks_pulseaudio()
    raise RuntimeError("No supported audio backend detected")


def get_current_default_sink(backend: str) -> Optional[Dict[str, Any]]:
    sinks = get_sinks(backend)
    if backend == "pipewire":
        default_id = parse_wpctl_default_sink_id()
        if default_id is None:
            return None
        return next((s for s in sinks if s["id"] == default_id), None)
    if backend == "pulseaudio":
        default_name = parse_pactl_default_sink_name()
        if default_name is None:
            return None
        return next((s for s in sinks if s["name"] == default_name), None)
    return None


def get_airplay_sinks(backend: str) -> List[Dict[str, Any]]:
    return [s for s in get_sinks(backend) if is_airplay_sink(s["props"]) or is_airplay_pulse_name(s)]


def is_airplay_pulse_name(sink: Dict[str, Any]) -> bool:
    name = (sink.get("name") or "").lower()
    desc = (sink.get("description") or "").lower()
    if "raop" in name:
        return True
    if "airplay" in desc or "raop" in desc:
        return True
    return False


def parse_raop_endpoint(node_name: str) -> Optional[Tuple[str, int]]:
    # Common formats:
    # raop_sink.<host>.local.<ip>.<port>
    # raop_sink.<host>.<ip>.<port>
    m = re.search(r"(\d+\.\d+\.\d+\.\d+)\.(\d+)$", node_name)
    if m:
        return (m.group(1), int(m.group(2)))
    m = re.search(r"(\d+\.\d+\.\d+\.\d+):(\d+)", node_name)
    if m:
        return (m.group(1), int(m.group(2)))
    return None


def check_tcp(host: str, port: int, timeout: float = 1.5) -> bool:
    try:
        with socket.create_connection((host, port), timeout=timeout):
            return True
    except Exception:
        return False


def get_pw_node_name(node_id: int) -> Optional[str]:
    if shutil.which("wpctl") is None:
        return None
    out = run(["wpctl", "inspect", str(node_id)], check=False)
    m_name = re.search(r"node.name = \"([^\"]+)\"", out)
    if m_name:
        return m_name.group(1)
    return None


def find_sink(query: str, sinks: List[Dict[str, Any]]) -> Dict[str, Any]:
    if query.isdigit():
        qid = int(query)
        for s in sinks:
            if s["id"] == qid:
                return s
        raise RuntimeError(f"No sink with id {qid}")

    q = query.lower()
    matches = [
        s
        for s in sinks
        if q in (s["name"] or "").lower() or q in (s["description"] or "").lower()
    ]
    if not matches:
        raise RuntimeError(f"No sink matching '{query}'")
    if len(matches) > 1:
        lines = ["Multiple matches:"]
        for s in matches:
            lines.append(f"  {s['id']}: {s['description'] or s['name']}")
        raise RuntimeError("\n".join(lines))
    return matches[0]


def sink_key(sink: Dict[str, Any]) -> str:
    # Prefer stable node name if present, else description/name.
    return sink.get("name") or sink.get("description") or ""


def parse_wpctl_default_sink_id() -> Optional[int]:
    if shutil.which("wpctl") is None:
        return None
    out = run(["wpctl", "status"], check=False)
    # Some versions print "Default Sink: <id>" or similar
    for line in out.splitlines():
        if line.strip().startswith("Default Sink:"):
            m = re.search(r"(\d+)", line)
            if m:
                try:
                    return int(m.group(1))
                except ValueError:
                    pass
    in_sinks = False
    for line in out.splitlines():
        if line.strip().startswith("Sinks:"):
            in_sinks = True
            continue
        if in_sinks:
            if line.strip().startswith("Sources:"):
                break
            m = re.search(r"\*\s*(\d+)\.\s+(.+)$", line)
            if m:
                try:
                    return int(m.group(1))
                except ValueError:
                    return None
    # Fallback: wpctl get-default (newer versions)
    out2 = run(["wpctl", "get-default"], check=False)
    m2 = re.search(r"(\d+)", out2)
    if m2:
        try:
            return int(m2.group(1))
        except ValueError:
            return None
    return None


def parse_pactl_default_sink_name() -> Optional[str]:
    if shutil.which("pactl") is None:
        return None
    out = run(["pactl", "info"], check=False)
    for line in out.splitlines():
        if line.startswith("Default Sink:"):
            return line.split(":", 1)[1].strip()
    return None


def set_default_sink(backend: str, sink_id: int, sink_name: str) -> None:
    if backend == "pipewire":
        require_tool("wpctl")
        run(["wpctl", "set-default", str(sink_id)])
        return
    if backend == "pulseaudio":
        require_tool("pactl")
        run(["pactl", "set-default-sink", sink_name])
        return
    raise RuntimeError("No supported audio backend detected")


def try_move_streams_pactl(target_sink_name: str, target_desc: str) -> bool:
    if shutil.which("pactl") is None:
        return False

    out = run(["pactl", "list", "short", "sinks"], check=False)
    sink_name = None
    for line in out.splitlines():
        parts = line.split()  # index name ...
        if len(parts) < 2:
            continue
        name = parts[1]
        if name == target_sink_name:
            sink_name = name
            break
    if sink_name is None:
        # Best-effort fallback: try a fuzzy match on description
        full = run(["pactl", "list", "sinks"], check=False)
        blocks = full.split("Sink #")
        for block in blocks[1:]:
            if target_desc and target_desc.lower() in block.lower():
                m = re.search(r"Name:\s+(\S+)", block)
                if m:
                    sink_name = m.group(1)
                    break
    if sink_name is None:
        return False

    inputs = run(["pactl", "list", "short", "sink-inputs"], check=False)
    moved = False
    for line in inputs.splitlines():
        parts = line.split()
        if not parts:
            continue
        idx = parts[0]
        run(["pactl", "move-sink-input", idx, sink_name], check=False)
        moved = True
    return moved


def pick_non_airplay_sink() -> Optional[Dict[str, Any]]:
    backend = detect_backend()
    sinks = get_sinks(backend)
    non = [s for s in sinks if not is_airplay_sink(s["props"]) and not is_airplay_pulse_name(s)]
    if not non:
        return None
    # Prefer sinks with "Built-in" in description, else first.
    for s in non:
        if "built-in" in (s["description"] or "").lower():
            return s
    return non[0]


def cmd_list(auto_ensure: bool, show_all: bool) -> int:
    backend = detect_backend()
    sinks = get_airplay_sinks(backend)
    if not sinks and auto_ensure and shutil.which("pactl") is not None:
        # Best-effort: load RAOP discovery and retry once.
        try:
            cmd_ensure_raop()
        except Exception:
            pass
        sinks = get_airplay_sinks(backend)

    all_sinks = get_sinks(backend)
    airplay = [s for s in all_sinks if is_airplay_sink(s["props"]) or is_airplay_pulse_name(s)]
    others = [s for s in all_sinks if s not in airplay]

    default_id = parse_wpctl_default_sink_id() if backend == "pipewire" else None
    default_name = parse_pactl_default_sink_name() if backend == "pulseaudio" else None

    def print_rows(title: str, rows: List[Dict[str, Any]]) -> None:
        if not rows:
            return
        items = []
        for s in rows:
            if backend == "pipewire":
                mark = "*" if default_id == s["id"] else " "
            else:
                mark = "*" if default_name == s["name"] else " "
            items.append((mark, str(s["id"]), s["description"] or s["name"]))
        w1 = max(len(r[0]) for r in items)
        w2 = max(len(r[1]) for r in items)
        print(title)
        for mark, sid, name in items:
            print(f" {mark:<{w1}} {sid:<{w2}}  {name}")

    if not airplay:
        print("No AirPlay sinks found. Try `airplay ensure-raop` or check avahi/raop setup.")

    # Always show AirPlay first.
    print_rows("AirPlay sinks:", airplay)
    if show_all:
        print_rows("Other sinks:", others)

    return 0 if airplay else 1


def cmd_diagnose() -> int:
    print("airplay diagnose")
    print("")
    print(f"Backend: {detect_backend()}")
    print("")
    print("Tools:")
    for tool in ("pw-dump", "wpctl", "pactl", "avahi-browse"):
        print(f"  {tool}: {'yes' if shutil.which(tool) else 'no'}")

    if shutil.which("systemctl") is not None:
        print("")
        print("Services:")
        for svc in ("avahi-daemon",):
            state = run(["systemctl", "is-active", svc], check=False).strip()
            print(f"  {svc}: {state}")
        # User services (best-effort)
        for svc in ("pipewire", "pipewire-pulse", "wireplumber"):
            state = run(["systemctl", "--user", "is-active", svc], check=False).strip()
            print(f"  {svc} (user): {state}")

    print("")
    print("RAOP module:")
    if shutil.which("pactl") is not None:
        mods = run(["pactl", "list", "modules"], check=False)
        print("  module-raop-discover: " + ("loaded" if "module-raop-discover" in mods else "not loaded"))
    else:
        print("  pactl not available")

    print("")
    print("AirPlay sinks:")
    sinks = get_airplay_sinks(detect_backend())
    if not sinks:
        print("  none detected")
    else:
        for s in sinks:
            print(f"  {s['id']}: {s['description'] or s['name']}")

    print("")
    print("RAOP devices (mDNS):")
    if shutil.which("avahi-browse") is not None:
        out = run(["avahi-browse", "-rt", "_raop._tcp"], check=False).strip()
        if not out:
            print("  none detected")
        else:
            lines = [ln for ln in out.splitlines() if ln and not ln.startswith("+") and not ln.startswith("=")]
            if not lines:
                print("  none detected")
            else:
                for ln in lines[:20]:
                    print(f"  {ln}")
    else:
        print("  avahi-browse not available")

    return 0


def cmd_check() -> int:
    backend = detect_backend()
    sinks = get_airplay_sinks(backend)
    if not sinks:
        print("No AirPlay sinks found.")
        return 1

    print("AirPlay reachability (TCP/7000):")
    any_ok = False
    for s in sinks:
        name = s["description"] or s["name"]
        endpoint = parse_raop_endpoint(s["name"] or "")
        node_name = s["name"] or ""
        if not endpoint and backend == "pipewire":
            node_name = get_pw_node_name(int(s["id"])) or node_name
            endpoint = parse_raop_endpoint(node_name)
        if not endpoint:
            print(f"  {s['id']}: {name} -> unknown endpoint (node.name: {node_name})")
            continue
        host, port = endpoint
        ok = check_tcp(host, port)
        any_ok = any_ok or ok
        status = "ok" if ok else "blocked/unreachable"
        print(f"  {s['id']}: {name} -> {host}:{port} [{status}]")

    if not any_ok:
        print("No reachable AirPlay endpoints. Device may be asleep, AirPlay 2-only, or blocked by network.")
        return 2
    return 0


def cmd_connect(target: Optional[str]) -> int:
    backend = detect_backend()
    sinks = get_airplay_sinks(backend)
    if not sinks and shutil.which("pactl") is not None:
        # Best-effort: load RAOP discovery and retry once.
        try:
            cmd_ensure_raop()
        except Exception:
            pass
        sinks = get_airplay_sinks(backend)
    if not sinks:
        raise RuntimeError("No AirPlay sinks found")

    if target is None:
        cfg = load_config()
        saved_key = cfg.get("default_sink_key")
        saved_id = cfg.get("default_sink")
        saved_backend = cfg.get("default_sink_backend")
        if saved_backend and saved_backend != backend:
            raise RuntimeError(
                f"Saved default is for backend '{saved_backend}', but current backend is '{backend}'"
            )
        if saved_key:
            match = next((s for s in sinks if sink_key(s) == saved_key), None)
            if match:
                target = str(match["id"])
        if target is None and saved_id:
            target = str(saved_id)
        if target is None:
            current = get_current_default_sink(backend)
            if current and (is_airplay_sink(current["props"]) or is_airplay_pulse_name(current)):
                target = str(current["id"])
            else:
                # Lowest id if no saved default
                target = str(sorted(sinks, key=lambda s: int(s["id"]))[0]["id"])

    sink = find_sink(target, sinks)

    set_default_sink(backend, int(sink["id"]), sink["name"])
    moved = try_move_streams_pactl(sink["name"], sink["description"])

    cfg = load_config()
    cfg["default_sink"] = sink["id"]
    cfg["default_sink_key"] = sink_key(sink)
    cfg["default_sink_name"] = sink["description"] or sink["name"]
    cfg["default_sink_backend"] = backend
    save_config(cfg)

    print(f"Default sink set to: {sink['description'] or sink['name']} (id {sink['id']})")
    if not moved:
        print("Note: existing streams may not move without pactl. New audio should route correctly.")
    return 0


def cmd_disconnect() -> int:
    sink = pick_non_airplay_sink()
    if sink is None:
        raise RuntimeError("No non-AirPlay sink found to disconnect to")
    backend = detect_backend()
    set_default_sink(backend, int(sink["id"]), sink["name"])
    moved = try_move_streams_pactl(sink["name"], sink["description"])
    print(f"Default sink set to: {sink['description'] or sink['name']} (id {sink['id']})")
    if not moved:
        print("Note: existing streams may not move without pactl. New audio should route correctly.")
    return 0


def cmd_status() -> int:
    backend = detect_backend()
    if backend == "pipewire":
        default_id = parse_wpctl_default_sink_id()
        if default_id is None:
            # Fallback to pactl if available
            default_name = parse_pactl_default_sink_name()
            if default_name:
                print(f"Default sink: {default_name} (name {default_name}, airplay unknown)")
                return 0
            print("Default sink: unknown (could not parse wpctl default)")
            return 1
        sinks = get_sinks(backend)
        current = next((s for s in sinks if s["id"] == default_id), None)
        if current is None:
            # Try to fetch name via wpctl inspect
            if shutil.which("wpctl") is not None:
                out = run(["wpctl", "inspect", str(default_id)], check=False)
                m_desc = re.search(r"node.description = \"([^\"]+)\"", out)
                m_name = re.search(r"node.name = \"([^\"]+)\"", out)
                label = None
                if m_desc:
                    label = m_desc.group(1)
                elif m_name:
                    label = m_name.group(1)
                if label:
                    print(f"Default sink: {label} (id {default_id}, airplay unknown)")
                    return 0
            # Fallback: map pactl default sink name to pw-dump
            default_name = parse_pactl_default_sink_name()
            if default_name:
                by_name = next((s for s in sinks if s["name"] == default_name), None)
                if by_name:
                    label = by_name["description"] or by_name["name"]
                    ap = "yes" if is_airplay_sink(by_name["props"]) else "no"
                    print(f"Default sink: {label} (id {by_name['id']}, airplay {ap})")
                    return 0
                print(f"Default sink: {default_name} (name {default_name}, id unknown)")
                return 0
            print(f"Default sink id: {default_id}")
            return 0
        label = current["description"] or current["name"]
        ap = "yes" if is_airplay_sink(current["props"]) else "no"
        print(f"Default sink: {label} (id {default_id}, airplay {ap})")
    elif backend == "pulseaudio":
        default_name = parse_pactl_default_sink_name()
        if default_name is None:
            print("Default sink: unknown (pactl not available)")
            return 1
        sinks = get_sinks(backend)
        current = next((s for s in sinks if s["name"] == default_name), None)
        if current is None:
            print(f"Default sink: {default_name}")
            return 0
        label = current["description"] or current["name"]
        ap = "yes" if is_airplay_pulse_name(current) else "no"
        print(f"Default sink: {label} (name {default_name}, airplay {ap})")
    else:
        print("Default sink: unknown (no supported backend)")
        return 1

    cfg = load_config()
    if "default_sink" in cfg:
        print(f"Saved AirPlay default: {cfg.get('default_sink_name')} (id {cfg.get('default_sink')})")
    return 0


def cmd_version() -> int:
    ver = os.environ.get("AIRPLAY_VERSION", "unknown")
    rev = os.environ.get("AIRPLAY_REV", "unknown")
    print(f"airplay {ver} ({rev})")
    return 0


def cmd_install_autostart() -> int:
    unit_dir = os.path.join(
        os.environ.get("XDG_CONFIG_HOME") or os.path.expanduser("~/.config"),
        "systemd",
        "user",
    )
    os.makedirs(unit_dir, exist_ok=True)
    unit_path = os.path.join(unit_dir, "airplay-autoconnect.service")

    unit = """[Unit]
Description=AirPlay autoconnect
After=pipewire.service pipewire-pulse.service wireplumber.service
Wants=pipewire.service pipewire-pulse.service wireplumber.service

[Service]
Type=oneshot
ExecStart=%h/.nix-profile/bin/airplay connect

[Install]
WantedBy=default.target
"""
    with open(unit_path, "w", encoding="utf-8") as f:
        f.write(unit)

    # Best-effort enable
    if shutil.which("systemctl") is not None:
        run(["systemctl", "--user", "daemon-reload"], check=False)
        run(["systemctl", "--user", "enable", "--now", "airplay-autoconnect.service"], check=False)

    print(f"Installed user unit: {unit_path}")
    print("Enabled and started airplay-autoconnect.service")
    return 0


def cmd_uninstall_autostart() -> int:
    unit_dir = os.path.join(
        os.environ.get("XDG_CONFIG_HOME") or os.path.expanduser("~/.config"),
        "systemd",
        "user",
    )
    unit_path = os.path.join(unit_dir, "airplay-autoconnect.service")

    if shutil.which("systemctl") is not None:
        run(["systemctl", "--user", "disable", "--now", "airplay-autoconnect.service"], check=False)
        run(["systemctl", "--user", "daemon-reload"], check=False)

    if os.path.exists(unit_path):
        os.remove(unit_path)
        print(f"Removed user unit: {unit_path}")
    else:
        print("User unit not found.")
    return 0


def cmd_ensure_raop() -> int:
    if shutil.which("pactl") is None:
        raise RuntimeError("pactl is required to load module-raop-discover")
    out = run(["pactl", "list", "modules"], check=False)
    if "module-raop-discover" in out:
        print("module-raop-discover already loaded")
        return 0
    run(["pactl", "load-module", "module-raop-discover"])
    print("Loaded module-raop-discover")
    return 0


def cmd_selftest() -> int:
    problems: List[str] = []
    warnings: List[str] = []
    backend = detect_backend()

    if backend == "pipewire":
        for tool in ("pw-dump", "wpctl"):
            if shutil.which(tool) is None:
                problems.append(f"missing required tool: {tool}")
    elif backend == "pulseaudio":
        if shutil.which("pactl") is None:
            problems.append("missing required tool: pactl")

    if shutil.which("pactl") is None:
        warnings.append("pactl not found (existing streams may not move)")

    # Test PipeWire + WirePlumber access
    if not problems and backend == "pipewire":
        try:
            run(["pw-dump"])
        except Exception as e:
            problems.append(f"pw-dump failed: {e}")
        try:
            run(["wpctl", "status"])
        except Exception as e:
            problems.append(f"wpctl status failed: {e}")
    elif not problems and backend == "pulseaudio":
        try:
            run(["pactl", "info"])
        except Exception as e:
            problems.append(f"pactl info failed: {e}")

    # Best-effort check for Avahi (system service)
    if shutil.which("systemctl") is not None:
        out = run(["systemctl", "is-active", "avahi-daemon"], check=False).strip()
        if out not in ("active", "activating"):
            warnings.append("avahi-daemon not active (RAOP discovery may fail)")

    if problems:
        print("Self-test failed:")
        for p in problems:
            print(f"  - {p}")
        if warnings:
            print("Warnings:")
            for w in warnings:
                print(f"  - {w}")
        return 2

    print("Self-test passed.")
    if warnings:
        print("Warnings:")
        for w in warnings:
            print(f"  - {w}")
    return 0


def main() -> int:
    parser = argparse.ArgumentParser(
        prog="airplay",
        description="Route system audio to AirPlay (RAOP) sinks via PipeWire",
    )
    sub = parser.add_subparsers(dest="cmd", required=True)

    sub.add_parser("help", help="Show help")
    p_list = sub.add_parser("list", help="List available AirPlay sinks")
    p_list.add_argument("--ensure", action="store_true", help="Attempt to load RAOP discovery before listing")
    p_list.add_argument("--all", action="store_true", help="Also show non-AirPlay sinks")

    p_connect = sub.add_parser("connect", help="Set default sink to an AirPlay device")
    p_connect.add_argument("target", nargs="?", help="Sink id or substring of device name")

    sub.add_parser("disconnect", help="Switch default sink back to a non-AirPlay device")
    sub.add_parser("status", help="Show current default sink")
    sub.add_parser("version", help="Show version information")
    sub.add_parser("install-autostart", help="Install a user service to auto-connect on login")
    sub.add_parser("uninstall-autostart", help="Remove the auto-connect user service")
    sub.add_parser("ensure-raop", help="Load module-raop-discover via pactl")
    sub.add_parser("selftest", help="Run basic dependency and connectivity checks")
    sub.add_parser("diagnose", help="Print detailed diagnostics")
    sub.add_parser("check", help="Check TCP reachability for AirPlay sinks")

    args = parser.parse_args()

    try:
        if args.cmd == "help":
            parser.print_help()
            return 0
        if args.cmd == "list":
            return cmd_list(args.ensure, args.all)
        if args.cmd == "connect":
            return cmd_connect(args.target)
        if args.cmd == "disconnect":
            return cmd_disconnect()
        if args.cmd == "status":
            return cmd_status()
        if args.cmd == "version":
            return cmd_version()
        if args.cmd == "install-autostart":
            return cmd_install_autostart()
        if args.cmd == "uninstall-autostart":
            return cmd_uninstall_autostart()
        if args.cmd == "ensure-raop":
            return cmd_ensure_raop()
        if args.cmd == "selftest":
            return cmd_selftest()
        if args.cmd == "diagnose":
            return cmd_diagnose()
        if args.cmd == "check":
            return cmd_check()
        parser.error("unknown command")
    except FileNotFoundError as e:
        print(f"Missing tool: {e}", file=sys.stderr)
        return 2
    except RuntimeError as e:
        print(str(e), file=sys.stderr)
        return 2


if __name__ == "__main__":
    raise SystemExit(main())
